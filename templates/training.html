{% extends "base.html" %}

{% block title %}Training - Stockmeister{% endblock %}

{% block extra_css %}
<style>
    /* Container margin entfernen */
    main.container.my-5 {
        margin-top: 0 !important;
        margin-bottom: 0 !important;
    }

    /* Flip Board Button */
    .flip-board-btn {
        position: absolute;
        top: 10px;
        left: -50px;
        width: 40px;
        height: 40px;
        background: rgba(44, 62, 80, 0.9);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        z-index: 10;
    }

    .flip-board-btn:hover {
        background: rgba(52, 73, 94, 0.95);
        border-color: var(--accent);
        transform: scale(1.05);
    }

    .flip-board-btn svg {
        width: 24px;
        height: 24px;
        fill: white;
    }

    /* Eigenes Schachbrett - CSS Grid */
    #chessboard {
        width: 100%; /* Nimmt volle Breite des Containers */
        margin: 0 auto;
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
        aspect-ratio: 1;
        position: relative;
        user-select: none;
    }

    /* Einzelne Felder */
    .square {
        position: relative;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Helle Felder */
    .square.light {
        background-color: #95a5a6;
    }

    /* Dunkle Felder */
    .square.dark {
        background-color: #2c3e50;
    }

    /* Koordinaten */
    .square .coord {
        position: absolute;
        font-size: 16px;
        font-weight: 700;
        opacity: 0.9;
        z-index: 1;
    }

    .square .coord.file {
        bottom: 3px;
        right: 4px;
    }

    .square .coord.rank {
        top: 3px;
        left: 4px;
    }

    .square.light .coord {
        color: #2c3e50;
    }

    .square.dark .coord {
        color: #95a5a6;
    }

    /* Figuren als Bilder */
    .square .piece {
        width: 95%;
        height: 95%;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        transition: transform 0.2s ease;
        /* pointer-events: none entfernt - jetzt kann man Figuren greifen */
    }

    /* Animation f√ºr bewegte Figuren */
    .piece-moving {
        position: fixed;
        width: 80px;
        height: 80px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        pointer-events: none;
        z-index: 1000;
        transition: all 0.5s ease-out;
    }

    .square.dragging .piece {
        opacity: 0.5;
    }

    /* Highlight-Klassen */
    .square.highlight-source {
        box-shadow: inset 0 0 0 4px rgba(0, 188, 212, 0.9);
        background-color: rgba(0, 188, 212, 0.3) !important;
    }

    .square.highlight-last-move {
        background-color: rgba(0, 188, 212, 0.4) !important;
    }

    .square.highlight-last-move.from {
        box-shadow: inset 0 0 0 3px rgba(100, 181, 246, 0.8);
    }

    .square.highlight-last-move.to {
        box-shadow: inset 0 0 0 3px rgba(25, 118, 210, 0.8);
    }

    .square.highlight-hover {
        box-shadow: inset 0 0 0 3px rgba(255, 255, 255, 0.9);
    }

    .square.dragging .piece {
        opacity: 0.4;
    }

    .dragging-piece-ghost {
        position: fixed;
        width: 80px;
        height: 80px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        pointer-events: none;
        z-index: 1000;
        opacity: 0.9;
        transform: translate(-50%, -50%);
    }

    /* Cyan Punkt f√ºr m√∂gliche Z√ºge */
    .square.highlight-possible::after {
        content: "";
        position: absolute;
        width: 30%;
        height: 30%;
        background-color: rgba(0, 188, 212, 0.6);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 5;
    }

    /* Cyan Ring f√ºr Schlagz√ºge */
    .square.highlight-capture::after {
        content: "";
        position: absolute;
        width: 90%;
        height: 90%;
        border: 8px solid rgba(0, 188, 212, 0.7);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: transparent;
        z-index: 5;
    }

    /* Visuelles Feedback auf Figuren */
    .square.move-correct::after {
        content: "‚úì";
        position: absolute;
        top: -15%;
        right: -15%;
        width: 50px;
        height: 50px;
        background: #27ae60;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.6);
        animation: checkmark-pop 0.5s ease-out;
    }

    .square.move-incorrect::after {
        content: "‚úó";
        position: absolute;
        top: -15%;
        right: -15%;
        width: 50px;
        height: 50px;
        background: #e74c3c;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        font-weight: bold;
        z-index: 100;
        box-shadow: 0 4px 12px rgba(231, 76, 60, 0.6);
        animation: checkmark-pop 0.5s ease-out;
    }

    @keyframes checkmark-pop {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        50% {
            transform: scale(1.2);
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    /* Evaluation Bar Container */
    .evaluation-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
    }

    .eval-bar-wrapper {
        width: 40px;
        align-self: stretch;
        background: #2c3e50;
        border-radius: 5px;
        position: relative;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        min-height: 400px;
    }

    .eval-bar-white {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: #ecf0f1;
        transition: height 0.3s ease;
        border-radius: 0 0 5px 5px;
    }

    .eval-score {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        font-weight: bold;
        color: #fff;
        background: rgba(44, 62, 80, 0.95);
        padding: 2px 6px;
        border-radius: 2px;
        z-index: 10;
        transition: top 0.3s ease;
        white-space: nowrap;
    }

    .board-eval-container {
        display: flex;
        align-items: stretch;
        justify-content: center;
        gap: 15px;
    }

    .board-wrapper {
        flex: 0 1 auto;
        width: min(85vh, 800px); /* Nutzt 85% der Viewport-H√∂he, max 800px */
        max-width: 100%;
        position: relative;
    }

    /* Responsive board wrapper */
    @media (min-width: 1600px) {
        .board-wrapper {
            width: min(80vh, 900px); /* Noch gr√∂√üer auf gro√üen Monitoren */
        }
    }

    @media (max-width: 1200px) {
        .board-wrapper {
            width: min(75vh, 650px);
        }
    }

    @media (max-width: 768px) {
        .board-wrapper {
            width: min(70vh, 500px);
        }
    }

    /* Coach Panel rechts */
    .coach-panel {
        flex: 0 0 350px;
        background: rgba(44, 62, 80, 0.3);
        border-radius: 10px;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .coach-panel-top {
        display: flex;
        flex-direction: column;
        gap: 15px;
        flex: 1;
    }

    .coach-header {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    .coach-avatar {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        object-fit: cover;
        object-position: center top;
        border: 3px solid var(--accent);
    }

    .coach-info h3 {
        margin: 0;
        font-size: 1.2rem;
        color: var(--text);
    }

    .coach-info p {
        margin: 0;
        font-size: 0.9rem;
        color: rgba(236, 240, 241, 0.7);
    }

    .coach-message {
        background: rgba(52, 73, 94, 0.5);
        border-left: 4px solid var(--accent);
        padding: 15px;
        border-radius: 5px;
    }

    .coach-message h4 {
        margin: 0 0 10px 0;
        font-size: 1rem;
        color: var(--accent);
    }

    .coach-message p {
        margin: 0;
        color: var(--text);
        line-height: 1.6;
    }

    .puzzle-info {
        background: rgba(52, 73, 94, 0.5);
        padding: 15px;
        border-radius: 5px;
    }

    .puzzle-info h4 {
        margin: 0 0 10px 0;
        font-size: 1rem;
        color: var(--text);
    }

    .puzzle-themes {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .theme-badge {
        background: var(--accent);
        color: white;
        padding: 5px 12px;
        border-radius: 15px;
        font-size: 0.85rem;
    }

    /* Stats und Buttons */
    .puzzle-stats {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        margin-top: 10px;
    }

    .stat-item {
        flex: 1;
        text-align: center;
        padding: 10px;
        background: rgba(52, 73, 94, 0.3);
        border-radius: 5px;
    }

    .stat-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--accent);
        display: block;
    }

    .stat-label {
        font-size: 0.8rem;
        color: rgba(236, 240, 241, 0.7);
    }

    .puzzle-actions {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .btn-puzzle {
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }

    /* Tipp Button - Blau/Info */
    .btn-hint {
        background: rgba(52, 152, 219, 0.15);
        color: #3498db;
        border: 2px solid rgba(52, 152, 219, 0.3);
    }

    .btn-hint:hover {
        background: rgba(52, 152, 219, 0.25);
        border-color: #3498db;
        transform: translateY(-2px);
    }

    /* L√∂sung Button - Orange/Warnung */
    .btn-solution {
        background: rgba(243, 156, 18, 0.15);
        color: #f39c12;
        border: 2px solid rgba(243, 156, 18, 0.3);
    }

    .btn-solution:hover {
        background: rgba(243, 156, 18, 0.25);
        border-color: #f39c12;
        transform: translateY(-2px);
    }

    /* N√§chstes Puzzle Button - Standard */
    .btn-next {
        background: rgba(149, 165, 166, 0.15);
        color: #95a5a6;
        border: 2px solid rgba(149, 165, 166, 0.3);
    }

    .btn-next:hover {
        background: rgba(149, 165, 166, 0.25);
        border-color: #95a5a6;
        transform: translateY(-2px);
    }

    /* N√§chstes Puzzle Button - Aktiv (gr√ºn nach Puzzle-L√∂sung) */
    .btn-next.active {
        background: #27ae60;
        color: white;
        border: 2px solid #27ae60;
        box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        animation: pulse 2s infinite;
    }

    .btn-next.active:hover {
        background: #229954;
        border-color: #229954;
        transform: translateY(-2px) scale(1.05);
    }

    @keyframes pulse {
        0%, 100% {
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }
        50% {
            box-shadow: 0 4px 20px rgba(39, 174, 96, 0.6);
        }
    }

    /* Erfolgs/Fehler Feedback */
    .feedback {
        padding: 15px;
        border-radius: 5px;
        text-align: center;
        font-weight: bold;
        display: none;
        animation: slideIn 0.3s ease;
    }

    .feedback.success {
        background: rgba(39, 174, 96, 0.2);
        border: 2px solid #27ae60;
        color: #27ae60;
    }

    .feedback.error {
        background: rgba(231, 76, 60, 0.2);
        border: 2px solid #e74c3c;
        color: #e74c3c;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Difficulty Badge */
    .difficulty-badge {
        display: inline-block;
        padding: 5px 12px;
        border-radius: 15px;
        font-size: 0.85rem;
        font-weight: bold;
    }

    .difficulty-easy {
        background: rgba(39, 174, 96, 0.2);
        color: #27ae60;
        border: 1px solid #27ae60;
    }

    .difficulty-medium {
        background: rgba(241, 196, 15, 0.2);
        color: #f1c40f;
        border: 1px solid #f1c40f;
    }

    .difficulty-hard {
        background: rgba(231, 76, 60, 0.2);
        color: #e74c3c;
        border: 1px solid #e74c3c;
    }

    @media (max-width: 1200px) {
        .board-eval-container {
            flex-wrap: wrap;
        }

        .coach-panel {
            flex: 1 1 100%;
            margin-top: 20px;
        }
    }
</style>
{% endblock %}

{% block content %}
{% if pattern_filter %}
<!-- Active Pattern Filter -->
<div class="row mb-3" style="margin-top: 10px;">
    <div class="col">
        <div class="alert" style="background: rgba(255, 107, 53, 0.2); border: 1px solid var(--accent); color: white; margin-bottom: 0;">
            üéØ Du trainierst gezielt: <strong>{{ pattern_translations.get(pattern_filter, pattern_filter) }}</strong>
            <a href="{{ url_for('training') }}" class="btn btn-sm btn-outline-light ms-2" style="float: right;">Normales Training</a>
        </div>
    </div>
</div>
{% endif %}

<div class="row" style="margin-top: {% if pattern_filter %}10px{% else %}10px{% endif %};">
    <div class="col">
        <!-- Board mit Evaluation Bar und Coach Panel -->
        <div class="board-eval-container">
            <!-- Evaluation Bar (hidden for puzzles) -->
            <div class="eval-bar-wrapper" style="display: none;">
                <div class="eval-bar-white" id="evalBarWhite" style="height: 50%;"></div>
                <div class="eval-score" id="evalScore">0.0</div>
            </div>

            <!-- Chessboard -->
            <div class="board-wrapper">
                <button class="flip-board-btn" id="flipBoardBtn" title="Board drehen">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3z"/>
                        <path d="M21 9l-3.99-4v3H10v2h7.01v3L21 9z"/>
                    </svg>
                </button>
                <div id="chessboard"></div>
            </div>

            <!-- Coach Panel -->
            <div class="coach-panel">
                <div class="coach-panel-top">
                    <!-- Coach Header -->
                    <div class="coach-header">
                        <img src="{{ url_for('static', filename='images/coach.jpg') }}" alt="Coach" class="coach-avatar">
                        <div class="coach-info">
                            <h3>Dein Coach</h3>
                            <p>Stockmeister</p>
                        </div>
                    </div>

                    <!-- Coach Nachricht - Direkt unter Header -->
                    <div class="coach-message" id="coachMessage">
                        <h4>Taktikaufgabe</h4>
                        <p>Finde den besten Zug f√ºr Wei√ü! √úberlege dir, welche taktischen Motive in der Stellung vorhanden sind.</p>
                    </div>

                    <!-- Feedback Box -->
                    <div class="feedback success" id="feedbackSuccess">
                        ‚úì Richtig! Sehr gut gespielt!
                    </div>
                    <div class="feedback error" id="feedbackError">
                        ‚ùå Nicht ganz, versuch's nochmal!
                    </div>
                </div>

                <!-- Action Buttons unten -->
                <div class="puzzle-actions">
                    <button class="btn-puzzle btn-hint" id="btnHint">
                        Tipp anzeigen
                    </button>
                    <button class="btn-puzzle btn-solution" id="btnSolution">
                        L√∂sung anzeigen
                    </button>
                    <button class="btn-puzzle btn-next" id="btnNext">
                        N√§chstes Puzzle
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script>
    // === EIGENES SCHACHBRETT SYSTEM ===
    var game = new Chess();
    var boardOrientation = 'white'; // 'white' oder 'black'
    var currentMoves = [];
    var lastMove = null;
    var currentEvaluation = 0.0;
    var selectedSquare = null;
    var draggingPiece = null;
    var draggingFrom = null;

    // Puzzle Daten
    var currentPuzzle = null;
    var currentSolutionMoves = [];
    var currentMoveIndex = 0;
    var patternFilter = {{ ('"%s"' % pattern_filter) if pattern_filter else 'null' }};
    var playerColor = 'w';

    // History Navigation
    var moveHistory = []; // Speichert alle gespielten Z√ºge
    var historyIndex = -1; // Aktueller Index in der History (-1 = aktuelle Position)
    var isViewingHistory = false; // Ob wir gerade in der History navigieren

    // Zeit-Tracking f√ºr Performance-Analytics
    var puzzleStartTime = null; // Timestamp wenn Puzzle geladen wird
    var puzzleSolveTime = null; // Zeit in Sekunden bis zur L√∂sung

    // Figuren-Bilder (Wikipedia)
    const pieceImages = {
        'wP': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',
        'wN': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
        'wB': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
        'wR': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
        'wQ': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
        'wK': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
        'bP': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
        'bN': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
        'bB': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
        'bR': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
        'bQ': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
        'bK': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg'
    };

    // Animiere Figuren-Bewegung
    function animateMove(from, to, callback) {
        console.log('Animating move from', from, 'to', to);

        // Hole die Figur BEVOR wir die Positionen suchen
        var piece = game.get(from);
        if (!piece) {
            console.error('No piece at', from);
            if (callback) callback();
            return;
        }

        var pieceCode = piece.color + piece.type.toUpperCase();
        var pieceImage = pieceImages[pieceCode];

        // Finde die DOM-Positionen der Felder
        var fromSquare = $(`[data-square="${from}"]`);
        var toSquare = $(`[data-square="${to}"]`);

        if (fromSquare.length === 0 || toSquare.length === 0) {
            console.error('Could not find squares:', from, fromSquare.length, to, toSquare.length);
            if (callback) callback();
            return;
        }

        // Hole die exakten DOM-Positionen (Offset gibt Position relativ zum Dokument)
        var fromPos = fromSquare.offset();
        var toPos = toSquare.offset();
        var squareSize = fromSquare.outerWidth();

        console.log('Square size:', squareSize, 'From:', fromPos, 'To:', toPos);

        // Berechne die Zentren der Felder
        var fromCenterX = fromPos.left + (squareSize / 2);
        var fromCenterY = fromPos.top + (squareSize / 2);
        var toCenterX = toPos.left + (squareSize / 2);
        var toCenterY = toPos.top + (squareSize / 2);

        // Erstelle animierte Figur (etwas kleiner als das Feld f√ºr bessere Optik)
        var pieceSize = squareSize * 0.9;
        var animatedPiece = $('<div>')
            .addClass('piece-moving')
            .css({
                'background-image': `url(${pieceImage})`,
                'left': fromCenterX + 'px',
                'top': fromCenterY + 'px',
                'width': pieceSize + 'px',
                'height': pieceSize + 'px',
                'transform': 'translate(-50%, -50%)',
                'transition': 'none' // Erst keine Transition
            });

        $('body').append(animatedPiece);

        // Verstecke Original-Figur w√§hrend Animation
        fromSquare.find('.piece').css('opacity', '0');

        // Starte Animation nach kurzer Verz√∂gerung (mit Transition)
        setTimeout(function() {
            animatedPiece.css({
                'transition': 'all 0.5s ease-out',
                'left': toCenterX + 'px',
                'top': toCenterY + 'px'
            });
        }, 20);

        // Nach Animation: Entferne animierte Figur und zeige Board neu
        setTimeout(function() {
            animatedPiece.remove();
            if (callback) callback();
        }, 540); // Etwas l√§nger als transition (0.5s)
    }

    // Board-Status rendern
    function renderBoard() {
        const boardEl = $('#chessboard');
        boardEl.empty();

        // chess.js board(): Index 0 = Rank 8, Index 7 = Rank 1
        const position = game.board();

        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                // Bestimme chess.js Position
                let rankIndex, fileIndex;

                if (boardOrientation === 'white') {
                    // White unten: row 0 = rank 8, row 7 = rank 1
                    rankIndex = row;
                    fileIndex = col;
                } else {
                    // Black unten: gespiegelt
                    rankIndex = 7 - row;
                    fileIndex = 7 - col;
                }

                // Schachnotation: a1-h8
                const fileChar = String.fromCharCode(97 + fileIndex); // a-h
                const rankNum = 8 - rankIndex; // 8-1
                const squareName = fileChar + rankNum;

                // Figur holen
                const piece = position[rankIndex][fileIndex];

                // Feldfarbe
                const isLight = (rankIndex + fileIndex) % 2 === 1;

                const square = $('<div>')
                    .addClass('square')
                    .addClass(isLight ? 'light' : 'dark')
                    .attr('data-square', squareName);

                // Koordinaten: Links (col=0) f√ºr Ranks, Unten (row=7) f√ºr Files
                if (col === 0) {
                    square.append(`<span class="coord rank">${rankNum}</span>`);
                }
                if (row === 7) {
                    square.append(`<span class="coord file">${fileChar}</span>`);
                }

                // Figur rendern
                if (piece) {
                    const pieceCode = piece.color + piece.type.toUpperCase();
                    const pieceDiv = $('<div>')
                        .addClass('piece')
                        .css('background-image', `url(${pieceImages[pieceCode]})`);
                    square.append(pieceDiv);
                }

                boardEl.append(square);
            }
        }
    }

    // Click & Drag Event-Handler - NUR EINMAL beim Start aufrufen!
    let eventsSetup = false;
    function setupSquareEvents() {
        if (eventsSetup) return; // Verhindere mehrfaches Registrieren
        eventsSetup = true;

        let mouseDownSquare = null;
        let mouseDownTime = 0;
        let hasMoved = false;

        // Event-Delegation: Auf #chessboard lauschen, f√ºr squares UND pieces
        $('#chessboard').on('mousedown', '.square, .piece', function(e) {
            if (e.button !== 0) return;

            // Finde das Square (kann .square oder .piece sein)
            let squareEl = $(this).hasClass('square') ? $(this) : $(this).closest('.square');
            mouseDownSquare = squareEl.attr('data-square');
            mouseDownTime = Date.now();
            hasMoved = false;

            console.log('Mousedown on:', mouseDownSquare);
        });

        $(document).on('mousemove', function(e) {
            if (mouseDownSquare && !hasMoved) {
                // Wenn Maus bewegt wird w√§hrend mousedown, starte Drag
                const piece = game.get(mouseDownSquare);
                if (piece && piece.color === playerColor) {
                    hasMoved = true;
                    handleDragStart(mouseDownSquare, e);
                }
            }
            if (draggingPiece) {
                hasMoved = true;
                updateDragGhost(e);
            }
        });

        $(document).on('mouseup', function(e) {
            const clickDuration = Date.now() - mouseDownTime;

            if (draggingPiece) {
                handleDragEnd();
            } else if (mouseDownSquare && !hasMoved && clickDuration < 300) {
                // War ein Click, kein Drag
                console.log('Detected click on:', mouseDownSquare);
                handleSquareClick(mouseDownSquare);
            }

            mouseDownSquare = null;
            hasMoved = false;
        });

        $('#chessboard').on('mouseenter', '.square', function() {
            if (draggingPiece) {
                $(this).addClass('highlight-hover');
            }
        });

        $('#chessboard').on('mouseleave', '.square', function() {
            $(this).removeClass('highlight-hover');
        });
    }

    // Click-to-Move Handler
    function handleSquareClick(square) {
        console.log('Click on:', square);

        // Keine Z√ºge im History-Modus
        if (isViewingHistory) {
            showCoachMessage('üìñ History-Modus', 'Du schaust dir gerade alte Z√ºge an. Nutze ‚Üê ‚Üí oder klicke auf "N√§chstes Puzzle" um fortzufahren.');
            return;
        }

        if (selectedSquare === null) {
            // Keine Figur ausgew√§hlt -> Versuche Figur auszuw√§hlen
            const piece = game.get(square);
            if (piece && piece.color === playerColor) {
                selectedSquare = square;
                showPossibleMoves(square);
            }
        } else {
            // Figur bereits ausgew√§hlt -> Versuche Zug
            if (square === selectedSquare) {
                // Auf gleiche Figur geklickt -> Abw√§hlen
                selectedSquare = null;
                removeHighlights();
            } else {
                makeMove(selectedSquare, square);
            }
        }
    }

    // Drag Start
    function handleDragStart(square, event) {
        // Kein Drag im History-Modus
        if (isViewingHistory) return;

        const piece = game.get(square);
        if (!piece || piece.color !== playerColor) return;

        draggingPiece = piece;
        draggingFrom = square;
        selectedSquare = null; // Reset click selection

        $(`[data-square="${square}"]`).addClass('dragging');
        showPossibleMoves(square);

        // Erstelle Ghost-Element
        const pieceCode = piece.color + piece.type.toUpperCase();
        const ghostEl = $('<div>')
            .addClass('dragging-piece-ghost')
            .css('background-image', `url(${pieceImages[pieceCode]})`)
            .css('left', event.pageX + 'px')
            .css('top', event.pageY + 'px');
        $('body').append(ghostEl);
    }

    // Update Ghost Position
    function updateDragGhost(event) {
        $('.dragging-piece-ghost').css({
            left: event.pageX + 'px',
            top: event.pageY + 'px'
        });
    }

    // Drag End
    function handleDragEnd() {
        $('.square').removeClass('dragging highlight-hover');
        $('.dragging-piece-ghost').remove();

        const dropSquare = $('.square:hover').attr('data-square');
        if (dropSquare && dropSquare !== draggingFrom) {
            makeMove(draggingFrom, dropSquare);
        } else {
            removeHighlights();
        }

        draggingPiece = null;
        draggingFrom = null;
    }

    // Zeige m√∂gliche Z√ºge
    function showPossibleMoves(square) {
        removeHighlights();

        $(`[data-square="${square}"]`).addClass('highlight-source');

        currentMoves = game.moves({square: square, verbose: true});

        currentMoves.forEach(move => {
            const targetSquare = $(`[data-square="${move.to}"]`);
            if (move.captured) {
                targetSquare.addClass('highlight-capture');
            } else {
                targetSquare.addClass('highlight-possible');
            }
        });
    }

    // Entferne alle Highlights
    function removeHighlights() {
        $('.square').removeClass('highlight-source highlight-possible highlight-capture highlight-hover');
        currentMoves = [];
    }

    // Mache einen Zug
    function makeMove(from, to) {
        const move = game.move({from: from, to: to, promotion: 'q'});

        if (move) {
            selectedSquare = null;
            removeHighlights();
            renderBoard();

            // Markiere letzten Zug
            $(`[data-square="${from}"]`).addClass('highlight-last-move from');
            $(`[data-square="${to}"]`).addClass('highlight-last-move to');
            lastMove = {from: from, to: to};

            console.log('Move made:', move);

            // WICHTIG: History wird NACH checkMove() gespeichert
            // checkMove() wird entscheiden, ob der Zug korrekt ist
            // Nur korrekte Z√ºge werden zur History hinzugef√ºgt

            // Pr√ºfe Puzzle-L√∂sung
            if (currentPuzzle) {
                checkMove(from, to, move);
            } else {
                // Kein Puzzle-Modus - speichere in History
                moveHistory.push({
                    move: move,
                    fen: game.fen()
                });
                historyIndex = -1;
            }
        } else {
            // Ung√ºltiger Zug - Check ob andere eigene Figur
            const clickedPiece = game.get(to);
            if (clickedPiece && clickedPiece.color === playerColor) {
                selectedSquare = to;
                showPossibleMoves(to);
            } else {
                selectedSquare = null;
                removeHighlights();
            }
        }
    }

    // Update Evaluation Bar
    function updateEvaluationBar(score) {
        // Score von -10 bis +10 auf 0-100% umrechnen
        // Positive Score = Wei√ü vorne, Negative = Schwarz vorne
        var percentage = 50;

        if (score >= 10) {
            percentage = 100;
        } else if (score <= -10) {
            percentage = 0;
        } else {
            percentage = 50 + (score * 5);
        }

        $('#evalBarWhite').css('height', percentage + '%');

        // Score Text formatieren und positionieren
        var scoreText = '';
        if (Math.abs(score) >= 100) {
            // Matt-Anzeige
            var mateIn = Math.floor(Math.abs(score) / 100);
            scoreText = (score > 0 ? 'M' : '-M') + mateIn;
        } else if (Math.abs(score) < 0.1) {
            scoreText = '0.0';
        } else {
            scoreText = score.toFixed(1);
        }

        $('#evalScore').text(scoreText);

        // Positioniere Score an der Grenze (100% - percentage, da von unten gemessen)
        var topPosition = (100 - percentage) + '%';
        $('#evalScore').css('top', topPosition);

        currentEvaluation = score;
    }

    // Note: removeHighlights is now defined earlier with the new board system

    // Markiere den letzten Zug
    // Highlight last move (kept for compatibility)
    function highlightLastMove(from, to) {
        $('.square').removeClass('highlight-last-move from to');
        if (from) $(`[data-square="${from}"]`).addClass('highlight-last-move from');
        if (to) $(`[data-square="${to}"]`).addClass('highlight-last-move to');
    }

    // Lade ein neues Puzzle vom Backend
    function loadPuzzle() {
        console.log('=== LADE NEUES PUZZLE ===');

        // Baue URL mit optionalem pattern-Parameter
        var url = '/api/get-puzzle';
        if (patternFilter) {
            url += '?pattern=' + encodeURIComponent(patternFilter);
            console.log('Loading puzzle with pattern filter:', patternFilter);
        }

        $.ajax({
            url: url,
            method: 'GET',
            success: function(response) {
                console.log('Backend Response:', response);
                if (response.success) {
                    currentPuzzle = response.puzzle;
                    currentSolutionMoves = currentPuzzle.moves;
                    currentMoveIndex = 0;

                    // Starte Zeit-Tracking
                    puzzleStartTime = Date.now();
                    puzzleSolveTime = null;

                    console.log('Puzzle ID:', currentPuzzle.id);
                    console.log('Puzzle FEN:', currentPuzzle.fen);
                    console.log('Puzzle geladen:', currentPuzzle);
                    console.log('Moves:', currentSolutionMoves);

                    // Reset History
                    moveHistory = [];
                    historyIndex = -1;
                    isViewingHistory = false;

                    // Reset Button-Status
                    $('#btnNext').removeClass('active');
                    $('#feedbackSuccess, #feedbackError').hide();

                    // Lade Position
                    game.load(currentPuzzle.fen);

                    // WICHTIG: Bei Lichess ist der ERSTE Zug in moves der Gegner-Zug!
                    // Diesen Zug m√ºssen wir abspielen und markieren
                    if (currentSolutionMoves.length > 0) {
                        var opponentInitialMove = currentSolutionMoves[0];
                        console.log('Playing opponent initial move:', opponentInitialMove);

                        // Parse UCI move
                        var from = opponentInitialMove.substring(0, 2);
                        var to = opponentInitialMove.substring(2, 4);
                        var promotion = opponentInitialMove.length > 4 ? opponentInitialMove.substring(4) : undefined;

                        // Spiele den Zug
                        var result = game.move({
                            from: from,
                            to: to,
                            promotion: promotion
                        });

                        if (result) {
                            console.log('Opponent move played successfully');
                            // Erh√∂he moveIndex, damit wir ab dem n√§chsten Zug (UNSER Zug) pr√ºfen
                            currentMoveIndex = 1;

                            // Speichere den Zug f√ºr Markierung
                            lastMove = { from: from, to: to };

                            // Speichere in History (Startposition)
                            moveHistory.push({
                                move: result,
                                fen: game.fen()
                            });
                        } else {
                            console.error('Failed to play opponent initial move');
                            lastMove = null;
                        }
                    }

                    // Setze Spielerfarbe (global) und Board-Orientierung
                    // JETZT ist game.turn() unsere Farbe (nach dem Gegner-Zug)
                    playerColor = game.turn(); // 'w' oder 'b'
                    console.log('Player color:', playerColor);

                    // Setze Board-Orientierung basierend auf Spielerfarbe
                    boardOrientation = playerColor === 'w' ? 'white' : 'black';
                    console.log('Board orientation:', boardOrientation);

                    // Rendere das Board
                    renderBoard();
                    console.log('Board rendered');

                    // Markiere den letzten Zug des Gegners
                    if (lastMove) {
                        $(`[data-square="${lastMove.from}"]`).addClass('highlight-last-move from');
                        $(`[data-square="${lastMove.to}"]`).addClass('highlight-last-move to');
                    }

                    // Update UI
                    updatePuzzleUI();

                    // Reset Feedback
                    $('#feedbackSuccess').hide();
                    $('#feedbackError').hide();

                    // Spielerfarbe wurde bereits oben gesetzt
                    var playerColorText = playerColor === 'w' ? 'Wei√ü' : 'Schwarz';

                    // Generiere hilfreichen Coaching-Text basierend auf Themes
                    var coachingText = '√úberlege dir, welche taktischen Motive in der Stellung vorhanden sind.';

                    if (currentPuzzle.themes.includes('fork')) {
                        coachingText = 'Achte darauf, ob du mehrere Figuren gleichzeitig angreifen kannst!';
                    } else if (currentPuzzle.themes.includes('pin')) {
                        coachingText = 'Pr√ºfe, ob du eine wichtige Figur gegen den K√∂nig fesseln kannst.';
                    } else if (currentPuzzle.themes.includes('mate') || currentPuzzle.themes.includes('mateIn1')) {
                        coachingText = 'Es gibt ein Matt! Finde den entscheidenden Zug.';
                    } else if (currentPuzzle.themes.includes('hangingPiece')) {
                        coachingText = 'Schau nach ungedeckten Figuren, die du gewinnen kannst.';
                    } else if (currentPuzzle.themes.includes('skewer')) {
                        coachingText = 'Suche nach einer M√∂glichkeit, zwei Figuren auf einer Linie anzugreifen.';
                    } else if (currentPuzzle.themes.includes('discoveredAttack')) {
                        coachingText = 'Kannst du durch Wegziehen einer Figur einen versteckten Angriff aufdecken?';
                    }

                    showCoachMessage('Taktikaufgabe', `Finde den besten Zug f√ºr ${playerColorText}! ${coachingText}`);

                    console.log('L√∂sung:', currentSolutionMoves);
                } else {
                    showFeedback(response.message || 'Fehler beim Laden des Puzzles', 'error');
                }
            },
            error: function(xhr, status, error) {
                console.error('Fehler beim Laden des Puzzles:', error);
                showFeedback('Fehler beim Laden des Puzzles. Bitte versuche es erneut.', 'error');
            }
        });
    }

    // Update Puzzle UI (Difficulty Badge, Themes)
    function updatePuzzleUI() {
        if (!currentPuzzle) return;

        // Update Difficulty Badge
        var rating = currentPuzzle.rating;
        var difficultyClass = 'difficulty-medium';
        var difficultyText = '‚≠ê‚≠ê Mittel';

        if (rating < 1400) {
            difficultyClass = 'difficulty-easy';
            difficultyText = '‚≠ê Leicht';
        } else if (rating > 1700) {
            difficultyClass = 'difficulty-hard';
            difficultyText = '‚≠ê‚≠ê‚≠ê Schwer';
        }

        // Schwierigkeits-Badge wird nicht mehr angezeigt (Spoiler)

        // Update Themes
        $('.puzzle-themes').empty();
        if (currentPuzzle.themes) {
            // Themes k√∂nnen als String (space-separated) oder Array kommen
            var themesArray = Array.isArray(currentPuzzle.themes)
                ? currentPuzzle.themes
                : currentPuzzle.themes.split(' ');

            // Deutsche √úbersetzungen f√ºr alle Lichess-Themes
            var germanThemes = {
                'mate': 'Matt',
                'mateIn1': 'Matt in 1',  // SPOILER - wird nicht angezeigt
                'mateIn2': 'Matt in 2',  // SPOILER - wird nicht angezeigt
                'mateIn3': 'Matt in 3',  // SPOILER - wird nicht angezeigt
                'mateIn4': 'Matt in 4',  // SPOILER - wird nicht angezeigt
                'mateIn5': 'Matt in 5',  // SPOILER - wird nicht angezeigt
                'fork': 'Gabel',
                'pin': 'Fesselung',
                'skewer': 'Spie√ü',
                'discoveredAttack': 'Abzugsangriff',
                'doubleCheck': 'Doppelschach',
                'hangingPiece': 'H√§ngende Figur',
                'trappedPiece': 'Gefangene Figur',
                'exposedKing': 'Exponierter K√∂nig',
                'backRankMate': 'Grundreihenmatt',
                'smotheredMate': 'Ersticktes Matt',
                'attraction': 'Hinlenkung',
                'deflection': 'Ablenkung',
                'sacrifice': 'Opfer',
                'clearance': 'R√§umung',
                'interference': 'Verstopfung',
                'intermezzo': 'Zwischenzug',
                'quietMove': 'Ruhiger Zug',
                'defensiveMove': 'Verteidigung',
                'castling': 'Rochade',
                'enPassant': 'En Passant',
                'promotion': 'Umwandlung',
                'underPromotion': 'Unterverwandlung',
                'xRayAttack': 'R√∂ntgenangriff',
                'zugzwang': 'Zugzwang',
                'kingsideAttack': 'K√∂nigsfl√ºgel-Angriff',
                'queensideAttack': 'Damenfl√ºgel-Angriff',
                'advantage': 'Vorteil',
                'crushing': 'Vernichtend',
                'equality': 'Ausgeglichen',
                'middlegame': 'Mittelspiel',
                'endgame': 'Endspiel',
                'opening': 'Er√∂ffnung',
                'rookEndgame': 'Turmendspiel',
                'bishopEndgame': 'L√§uferendspiel',
                'pawnEndgame': 'Bauernendspiel',
                'knightEndgame': 'Springerendspiel',
                'queenEndgame': 'Damenendspiel',
                'queenRookEndgame': 'Dame-Turm-Endspiel',
                'short': 'Kurz',
                'long': 'Lang',
                'veryLong': 'Sehr lang',
                'oneMove': '1 Zug',
                'master': 'Meisterpartie',
                'masterVsMaster': 'Meister vs Meister',
                'superGM': 'Super-GM'
            };

            // ANTI-SPOILER: Filtere alle Themes, die zu viel verraten
            var spoilerThemes = [
                'mate', 'mateIn1', 'mateIn2', 'mateIn3', 'mateIn4', 'mateIn5',  // Matt-Themes verraten L√∂sung
                'oneMove', 'short', 'long', 'veryLong',  // L√§ngen-Infos sind Spoiler
                'master', 'masterVsMaster', 'superGM',  // Unn√∂tige Infos
                'advantage', 'crushing', 'equality',  // Bewertungen sind Spoiler
                'middlegame', 'endgame', 'opening'  // Zu generisch
            ];
            var displayedCount = 0;

            themesArray.forEach(function(theme) {
                if (displayedCount >= 3) return; // Max 3 Themes
                if (spoilerThemes.includes(theme)) return; // √úberspringe Spoiler-Themes

                var displayTheme = germanThemes[theme] || theme;
                $('.puzzle-themes').append(`<span class="theme-badge">${displayTheme}</span> `);
                displayedCount++;
            });

            // Falls keine Themes √ºbrig sind, zeige generisches "Taktik"
            if (displayedCount === 0) {
                $('.puzzle-themes').append(`<span class="theme-badge">Taktik</span>`);
            }
        }
    }

    // Click-to-Move: Wenn auf ein Feld geklickt wird
    function onSquareClick(square) {
        console.log('onSquareClick called for:', square);
        console.log('selectedSquare is currently:', selectedSquare);

        // Fall 1: Es ist noch keine Figur ausgew√§hlt
        if (selectedSquare === null) {
            var piece = game.get(square);
            console.log('Piece on square:', piece);

            // Nur wenn auf dem Feld eine Figur steht
            if (!piece) {
                console.log('No piece on this square');
                return;
            }

            // Nur eigene Figuren ausw√§hlen (dynamische Farbe)
            if (piece.color !== playerColor) {
                console.log('Wrong color - not player color');
                return;
            }

            // Figur ausw√§hlen
            console.log('Selecting piece on', square);
            selectedSquare = square;
            showPossibleMoves(square);
            return;
        }

        // Fall 2: Eine Figur ist bereits ausgew√§hlt
        // Versuch den Zug zu machen
        var move = game.move({
            from: selectedSquare,
            to: square,
            promotion: 'q'
        });

        // Ung√ºltiger Zug?
        if (move === null) {
            // Wenn auf ein anderes eigenes Feld geklickt wurde, w√§hle diese Figur aus
            var clickedPiece = game.get(square);
            if (clickedPiece && clickedPiece.color === playerColor) {
                selectedSquare = square;
                showPossibleMoves(square);
            } else {
                // Sonst: Auswahl aufheben
                selectedSquare = null;
                removeHighlights();
            }
            return;
        }

        // Zug war g√ºltig
        selectedSquare = null;
        removeHighlights();

        // Verwende ChessboardJS move() f√ºr saubere Animation
        var moveConfig = {};
        moveConfig[move.from] = move.to;
        board.move(moveConfig);

        lastMove = {from: move.from, to: move.to};
        highlightLastMove(move.from, move.to);
        console.log('Zug gemacht via click:', move);

        // Check ob der Zug korrekt ist (f√ºr Puzzles)
        checkMove(move.from, move.to);
    }

    $(document).ready(function() {
        console.log('Initialisiere eigenes Schachbrett-System...');

        // Rendere initiales leeres Board
        renderBoard();

        // Setze Event-Listener (nur einmal!)
        setupSquareEvents();

        // Setze initiale Evaluation
        updateEvaluationBar(0.0);

        // Lade das erste Puzzle
        loadPuzzle();

        // Flip Board Button
        $('#flipBoardBtn').on('click', function() {
            boardOrientation = boardOrientation === 'white' ? 'black' : 'white';
            renderBoard();

            // Highlights wieder anwenden falls vorhanden
            if (lastMove) {
                $(`[data-square="${lastMove.from}"]`).addClass('highlight-last-move from');
                $(`[data-square="${lastMove.to}"]`).addClass('highlight-last-move to');
            }
            if (selectedSquare) {
                showPossibleMoves(selectedSquare);
            }
        });

        // Button Event Handlers
        $('#btnHint').on('click', function() {
            if (!currentPuzzle) {
                showFeedback('Bitte lade zuerst ein Puzzle', 'error');
                return;
            }

            // Generiere einen Tipp basierend auf dem Theme
            var hintText = '√úberlege dir, welcher Zug am st√§rksten ist.';

            if (currentPuzzle.themes.includes('fork')) {
                hintText = 'Schau dir an, ob du mit einem Zug zwei gegnerische Figuren gleichzeitig angreifen kannst (Gabel).';
            } else if (currentPuzzle.themes.includes('pin')) {
                hintText = 'Gibt es eine M√∂glichkeit, eine wichtige Figur zu fesseln?';
            } else if (currentPuzzle.themes.includes('mate') || currentPuzzle.themes.includes('mateIn1')) {
                hintText = 'Suche nach einem Matt! Der K√∂nig ist in Gefahr.';
            } else if (currentPuzzle.themes.includes('hangingPiece')) {
                hintText = 'Eine gegnerische Figur ist ungedeckt. Kannst du sie gewinnen?';
            }

            showCoachMessage('üí° Tipp', hintText);
        });

        $('#btnSolution').on('click', function() {
            if (!currentPuzzle || currentSolutionMoves.length === 0) {
                showFeedback('Bitte lade zuerst ein Puzzle', 'error');
                return;
            }

            // Reset: Lade das Puzzle neu, um von vorne zu starten
            game.load(currentPuzzle.fen);
            moveHistory = [];
            historyIndex = -1;
            isViewingHistory = false;

            // Spiele den initialen Gegner-Zug
            if (currentSolutionMoves.length > 0) {
                var opponentInitialMove = currentSolutionMoves[0];
                var from = opponentInitialMove.substring(0, 2);
                var to = opponentInitialMove.substring(2, 4);
                var promotion = opponentInitialMove.length > 4 ? opponentInitialMove.substring(4) : undefined;

                var result = game.move({
                    from: from,
                    to: to,
                    promotion: promotion
                });

                if (result) {
                    moveHistory.push({
                        move: result,
                        fen: game.fen()
                    });
                }
            }

            // Rendere Board
            renderBoard();
            removeHighlights();

            // Markiere als nicht gel√∂st
            submitPuzzleResult(false);

            showCoachMessage('üîç L√∂sung', 'Die L√∂sung wird Schritt f√ºr Schritt angezeigt...');
            showFeedback('L√∂sung wird abgespielt...', 'error');

            // Spiele alle verbleibenden Z√ºge der L√∂sung ab (mit Animation)
            function playNextSolutionMove(moveIdx) {
                if (moveIdx >= currentSolutionMoves.length) {
                    // Alle Z√ºge abgespielt
                    showCoachMessage('Puzzle beendet', 'Das war die vollst√§ndige L√∂sung. Nutze die Pfeiltasten ‚Üê ‚Üí um durch die Z√ºge zu navigieren.');
                    return;
                }

                var move = currentSolutionMoves[moveIdx];
                var from = move.substring(0, 2);
                var to = move.substring(2, 4);
                var promotion = move.length > 4 ? move.substring(4) : undefined;

                // Animiere den Zug BEVOR er gemacht wird
                animateMove(from, to, function() {
                    // Mache den Zug nach der Animation
                    var result = game.move({
                        from: from,
                        to: to,
                        promotion: promotion
                    });

                    if (result) {
                        // Speichere in History
                        moveHistory.push({
                            move: result,
                            fen: game.fen()
                        });

                        // Update Board
                        renderBoard();
                        removeHighlights();
                        $(`[data-square="${from}"]`).addClass('highlight-last-move from');
                        $(`[data-square="${to}"]`).addClass('highlight-last-move to');

                        // N√§chsten Zug nach 0.7 Sekunden abspielen (Animation braucht 0.5s)
                        setTimeout(function() {
                            playNextSolutionMove(moveIdx + 1);
                        }, 700);
                    } else {
                        console.error('Failed to play solution move:', move);
                        playNextSolutionMove(moveIdx + 1); // √úberspringe fehlerhaften Zug
                    }
                });
            }

            // Starte ab Move-Index 1 (da 0 der initiale Gegner-Zug war)
            playNextSolutionMove(1);
        });

        $('#btnNext').on('click', function() {
            // Lade n√§chstes Puzzle
            loadPuzzle();
        });

        // Pfeil-Tasten Navigation f√ºr History
        $(document).on('keydown', function(e) {
            // Nur wenn wir eine History haben
            if (moveHistory.length === 0) return;

            if (e.key === 'ArrowLeft') {
                // Zur√ºck
                e.preventDefault();
                navigateHistory(-1);
            } else if (e.key === 'ArrowRight') {
                // Vorw√§rts
                e.preventDefault();
                navigateHistory(1);
            }
        });
    });

    // Navigation durch die Move-History
    function navigateHistory(direction) {
        if (moveHistory.length === 0) return;

        // Wenn wir aktuell bei -1 sind (aktuelle Position) und zur√ºck gehen
        // dann gehen wir zum letzten Element in der History
        if (historyIndex === -1 && direction < 0) {
            historyIndex = moveHistory.length - 1;
        } else {
            // Normaler Fall: Bewege Index
            var newIndex = historyIndex + direction;

            // Grenzen pr√ºfen - STOPPE bei Start und Ende
            if (newIndex < 0) {
                return; // Bereits am Start, nicht weiter zur√ºck
            } else if (newIndex >= moveHistory.length) {
                // Am Ende angekommen, gehe zu aktueller Position
                if (historyIndex === moveHistory.length - 1) {
                    historyIndex = -1;
                } else {
                    return; // Bereits am Ende
                }
            } else {
                historyIndex = newIndex;
            }
        }

        isViewingHistory = (historyIndex !== -1);

        console.log('Navigate to history index:', historyIndex);

        if (historyIndex === -1) {
            // Aktuelle Position - zeige das aktuelle game
            renderBoard();

            // Zeige letzten Zug
            if (moveHistory.length > 0) {
                var lastMove = moveHistory[moveHistory.length - 1].move;
                removeHighlights();
                $(`[data-square="${lastMove.from}"]`).addClass('highlight-last-move from');
                $(`[data-square="${lastMove.to}"]`).addClass('highlight-last-move to');
            }

            // Zeige normale Nachricht wenn zur√ºck zur aktuellen Position
            showCoachMessage('Taktikaufgabe', 'Du bist zur√ºck bei der aktuellen Position.');
        } else {
            // Historische Position anzeigen
            var historyEntry = moveHistory[historyIndex];

            // Lade diese FEN-Position tempor√§r
            var currentFen = game.fen(); // Speichere aktuelle Position
            game.load(historyEntry.fen);
            renderBoard();

            // Markiere den Zug dieser Position
            removeHighlights();
            $(`[data-square="${historyEntry.move.from}"]`).addClass('highlight-last-move from');
            $(`[data-square="${historyEntry.move.to}"]`).addClass('highlight-last-move to');

            // Zeige Hinweis
            showCoachMessage('üìñ History-Modus', `Zug ${historyIndex + 1} von ${moveHistory.length}. Nutze ‚Üê ‚Üí um zu navigieren.`);
        }
    }

    // Zeige Coach Nachricht
    function showCoachMessage(title, message) {
        $('#coachMessage h4').text(title);
        $('#coachMessage p').text(message);
    }

    // === INTELLIGENTES ERKL√ÑRUNGS-SYSTEM ===
    // Generiere taktische Erkl√§rung basierend auf Pattern und Situation
    function getPatternExplanation(pattern, moveNumber, isCorrect) {
        var explanations = {
            'fork': {
                intro: 'Bei einer Gabel greifen wir zwei oder mehr gegnerische Figuren gleichzeitig an.',
                correctMove: [
                    'Perfekt! Du hast die Gabel gesehen. Dein Springer/Bauer greift jetzt mehrere Figuren gleichzeitig an.',
                    'Sehr gut! Diese Gabel zwingt den Gegner, eine seiner Figuren zu opfern.',
                    'Exzellent! Der Doppelangriff gibt dem Gegner keine gute Verteidigung.'
                ],
                wrongMove: [
                    'Suche nach einem Zug, der zwei gegnerische Figuren gleichzeitig angreift.',
                    '√úberlege: Welche Figur kann ich so platzieren, dass sie mehrere Ziele bedroht?',
                    'Eine Gabel bedeutet Doppelangriff - der Gegner kann nicht beide Figuren retten.'
                ],
                nextMove: 'Achte darauf, welche Figur der Gegner retten wird, und schlage dann die andere.'
            },
            'pin': {
                intro: 'Eine Fesselung verhindert, dass eine Figur ziehen kann, weil sonst eine wertvollere Figur dahinter geschlagen w√ºrde.',
                correctMove: [
                    'Ausgezeichnet! Diese Fesselung macht die gegnerische Figur bewegungsunf√§hig.',
                    'Sehr gut! Der Gegner kann diese gefesselte Figur nicht bewegen, ohne Material zu verlieren.',
                    'Perfekt! Die Fesselung nutzt die Geometrie des Bretts optimal aus.'
                ],
                wrongMove: [
                    'Suche nach einer M√∂glichkeit, eine gegnerische Figur zu fesseln.',
                    '√úberlege: Kann ich eine Linie (Reihe, Linie oder Diagonale) nutzen, um zwei Figuren zu bedrohen?',
                    'Bei einer Fesselung steht eine weniger wertvolle Figur vor einer wertvolleren.'
                ],
                nextMove: 'Nutze jetzt die Tatsache, dass die gefesselte Figur sich nicht verteidigen kann.'
            },
            'skewer': {
                intro: 'Ein Spie√ü zwingt eine wertvolle Figur zum Wegziehen, wodurch eine Figur dahinter geschlagen werden kann.',
                correctMove: [
                    'Perfekt! Der Spie√ü zwingt die wertvolle Figur zum Ziehen.',
                    'Ausgezeichnet! Jetzt muss der K√∂nig/Die Dame weichen und gibt eine Figur preis.',
                    'Sehr gut! Das ist das Gegenteil einer Fesselung - die wertvollere Figur steht vorne.'
                ],
                wrongMove: [
                    'Suche nach einer Linie, auf der eine wertvolle gegnerische Figur vor einer anderen steht.',
                    'Ein Spie√ü bedroht zwei Figuren auf einer Linie - die vordere (wertvollere) muss ziehen.',
                    '√úberlege: Welche Fernfigur (Dame, Turm, L√§ufer) kann ich nutzen?'
                ],
                nextMove: 'Schlage jetzt die nun ungedeckte Figur.'
            },
            'discoveredAttack': {
                intro: 'Ein Abzugsangriff entsteht, wenn eine Figur wegzieht und dadurch eine dahinterstehende Figur einen Angriff er√∂ffnet.',
                correctMove: [
                    'Brillant! Der Abzugsangriff gibt dem Gegner zwei Probleme gleichzeitig.',
                    'Perfekt! Die wegziehende Figur UND die dahinterstehende Figur bedrohen nun etwas.',
                    'Ausgezeichnet! Solche Abzugsangriffe sind oft entscheidend.'
                ],
                wrongMove: [
                    'Suche nach einer Figur, die du wegziehen kannst, um einen Angriff zu er√∂ffnen.',
                    '√úberlege: Steht eine deiner Figuren vor einer Fernfigur, die einen Angriff ausf√ºhren k√∂nnte?',
                    'Der Trick ist, dass BEIDE Figuren gleichzeitig drohen - eine durch Wegziehen, eine durch Aufdecken.'
                ],
                nextMove: 'Der Gegner kann nicht beide Bedrohungen abwehren.'
            },
            'hangingPiece': {
                intro: 'Eine h√§ngende Figur ist unverteidigt oder nur unzureichend gedeckt und kann geschlagen werden.',
                correctMove: [
                    'Gut gesehen! Die ungedeckte Figur ist jetzt deine.',
                    'Richtig! Der Gegner hat diese Figur nicht ausreichend gesch√ºtzt.',
                    'Perfekt! Immer nach h√§ngenden Figuren Ausschau halten.'
                ],
                wrongMove: [
                    'Schaue nach gegnerischen Figuren, die unverteidigt oder schlecht gedeckt sind.',
                    '√úberlege: Welche Figur des Gegners hat keinen oder nur unzureichenden Schutz?',
                    'Z√§hle Angreifer und Verteidiger - gibt es eine Figur, die du g√ºnstig tauschen kannst?'
                ],
                nextMove: 'Nutze deinen Materialvorteil jetzt aus.'
            },
            'sacrifice': {
                intro: 'Ein Opfer gibt bewusst Material ab, um einen gr√∂√üeren taktischen oder positionellen Vorteil zu erlangen.',
                correctMove: [
                    'Mutig und richtig! Das Opfer √∂ffnet entscheidende Linien oder Diagonalen.',
                    'Brillant! Manchmal muss man Material geben, um den K√∂nig anzugreifen.',
                    'Perfekt! Dieses Opfer verschafft dir einen unstoppbaren Angriff.'
                ],
                wrongMove: [
                    'Manchmal ist der beste Zug, Material zu opfern. Schaue nach aggressiven M√∂glichkeiten.',
                    '√úberlege: Was erreiche ich, wenn ich diese Figur opfere? Gibt es eine Folge?',
                    'Nicht immer ist der materiell beste Zug auch der st√§rkste. Suche nach einem Durchbruch.'
                ],
                nextMove: 'Nutze jetzt die Schw√§che in der gegnerischen Stellung, die du geschaffen hast.'
            },
            'backRankMate': {
                intro: 'Ein Grundreihenmatt nutzt aus, dass der gegnerische K√∂nig auf der Grundreihe gefangen ist.',
                correctMove: [
                    'Exzellent! Der K√∂nig hat keinen Fluchtweg mehr.',
                    'Perfekt! Die eigenen Bauern blockieren den Fluchtweg - das ist Matt!',
                    'Sehr gut! Grundreihenmatt ist ein klassisches Muster.'
                ],
                wrongMove: [
                    'Schaue auf die gegnerische Grundreihe. Ist der K√∂nig dort gefangen?',
                    '√úberlege: Kann ich mit einem Turm oder einer Dame die Grundreihe angreifen?',
                    'Der K√∂nig hat oft keine Fluchtfelder, wenn die eigenen Bauern noch vor ihm stehen.'
                ],
                nextMove: 'Das ist Matt - das Puzzle ist gel√∂st!'
            },
            'trappedPiece': {
                intro: 'Eine gefangene Figur hat keine guten Zugm√∂glichkeiten mehr und kann eingekesselt werden.',
                correctMove: [
                    'Sehr gut! Die Figur ist jetzt gefangen und kann nicht mehr entkommen.',
                    'Perfekt! Du hast die Fluchtwege systematisch abgeschnitten.',
                    'Ausgezeichnet! Die gefangene Figur wird Material kosten.'
                ],
                wrongMove: [
                    'Suche nach einer gegnerischen Figur, die schlecht platziert ist und wenige Felder hat.',
                    '√úberlege: Kann ich die Fluchtfelder dieser Figur kontrollieren?',
                    'Gefangene Figuren stehen oft am Brettrand oder in der eigenen Bauernstruktur.'
                ],
                nextMove: 'Schlie√üe das Netz jetzt und gewinne die gefangene Figur.'
            },
            'exposedKing': {
                intro: 'Ein exponierter K√∂nig ohne Schutz ist anf√§llig f√ºr Angriffe.',
                correctMove: [
                    'Ausgezeichnet! Der ungesch√ºtzte K√∂nig wird jetzt zum Ziel.',
                    'Perfekt! Nutze die fehlende Deckung f√ºr einen direkten Angriff.',
                    'Sehr gut! Ein exponierter K√∂nig ist immer in Gefahr.'
                ],
                wrongMove: [
                    'Schaue auf den gegnerischen K√∂nig. Fehlt ihm Schutz durch Bauern oder Figuren?',
                    '√úberlege: Welche Figuren k√∂nnen den exponierten K√∂nig direkt angreifen?',
                    'Ein ungesch√ºtzter K√∂nig ist die gr√∂√üte Schw√§che - nutze sie aus!'
                ],
                nextMove: 'Erh√∂he den Druck auf den K√∂nig weiter.'
            }
        };

        var patternData = explanations[pattern] || explanations['hangingPiece']; // Fallback

        if (isCorrect) {
            // W√§hle zuf√§llige Erfolgsmeldung
            var messages = patternData.correctMove;
            return messages[Math.floor(Math.random() * messages.length)];
        } else {
            // W√§hle zuf√§llige Hilfsmeldung
            var messages = patternData.wrongMove;
            return messages[Math.floor(Math.random() * messages.length)];
        }
    }

    // Zeige visuelles Feedback auf Figur (gr√ºner Haken / rotes X)
    function showVisualFeedback(square, isCorrect) {
        var $square = $(`[data-square="${square}"]`);

        // Entferne alte Feedback-Klassen von allen Feldern
        $('.square').removeClass('move-correct move-incorrect');

        // F√ºge neue Feedback-Klasse hinzu
        if (isCorrect) {
            $square.addClass('move-correct');
        } else {
            $square.addClass('move-incorrect');
        }

        // Entferne Feedback nach 1.5 Sekunden
        setTimeout(function() {
            $square.removeClass('move-correct move-incorrect');
        }, 1500);
    }

    // Zeige gro√üe Erfolgsmeldung (nur bei Puzzle-L√∂sung)
    function showSuccessMessage() {
        var feedbackEl = $('#feedbackSuccess');
        feedbackEl.text('‚úì Puzzle gel√∂st! Sehr gut!').fadeIn();
        // Bleibt sichtbar, kein Auto-Hide
    }

    // Zeige Feedback (f√ºr Fehler-Meldungen, die im Toast bleiben)
    function showFeedback(message, type) {
        var feedbackEl = type === 'success' ? $('#feedbackSuccess') : $('#feedbackError');
        var otherEl = type === 'success' ? $('#feedbackError') : $('#feedbackSuccess');

        // Verstecke das andere Feedback
        otherEl.hide();

        // Zeige das neue Feedback
        feedbackEl.text(message).fadeIn();

        // Nach 5 Sekunden wieder ausblenden (verl√§ngert von 3 auf 5 Sekunden)
        setTimeout(function() {
            feedbackEl.fadeOut();
        }, 5000);
    }

    // Highlight L√∂sung auf dem Brett
    function highlightSolution() {
        // Beispiel: Markiere f3 und e5
        removeHighlights();
        $('#chessboard .square-f3').addClass('highlight-source');
        $('#chessboard .square-e5').addClass('highlight-possible');
    }

    // Check ob Zug korrekt ist
    function checkMove(from, to, moveObj) {
        if (!currentPuzzle || currentSolutionMoves.length === 0) {
            console.log('Kein Puzzle geladen');
            return false;
        }

        // Konvertiere den gespielten Zug zu UCI
        var playedMove = from + to;

        // Hole den erwarteten Zug
        var expectedMove = currentSolutionMoves[currentMoveIndex];

        console.log('Gespielter Zug:', playedMove);
        console.log('Erwarteter Zug:', expectedMove);
        console.log('Move Index:', currentMoveIndex);

        // Vergleiche (ber√ºcksichtige auch Promotion)
        var isCorrect = playedMove === expectedMove.substring(0, 4);

        if (isCorrect) {
            // NUR bei korrektem Zug: Speichere in History
            moveHistory.push({
                move: moveObj,
                fen: game.fen()
            });
            historyIndex = -1;

            currentMoveIndex++;

            // Ist das Puzzle gel√∂st?
            if (currentMoveIndex >= currentSolutionMoves.length) {
                // Puzzle komplett gel√∂st!
                showVisualFeedback(to, true); // Gr√ºner Haken auf letztem Zug
                showSuccessMessage(); // Gro√üe Erfolgsmeldung
                showCoachMessage('Ausgezeichnet!', 'Du hast das Puzzle erfolgreich gel√∂st!');

                // Sende Erfolg an Backend
                submitPuzzleResult(true);

                // Button gr√ºn highlighten statt Auto-Load
                $('#btnNext').addClass('active');

                return true;
            } else {
                // Zug war richtig, aber es gibt noch weitere Z√ºge
                showVisualFeedback(to, true); // Gr√ºner Haken
                var pattern = currentPuzzle.tactical_pattern || 'hangingPiece';
                var explanation = getPatternExplanation(pattern, currentMoveIndex, true);
                showCoachMessage('Sehr gut!', explanation);

                // Der n√§chste Zug in der L√∂sung ist der Gegner-Zug - spiele ihn automatisch
                setTimeout(function() {
                    var opponentMove = currentSolutionMoves[currentMoveIndex];
                    console.log('Auto-playing opponent move:', opponentMove);

                    // Parse UCI move (z.B. "e7e5" oder "e7e8q" mit Promotion)
                    var from = opponentMove.substring(0, 2);
                    var to = opponentMove.substring(2, 4);
                    var promotion = opponentMove.length > 4 ? opponentMove.substring(4) : undefined;

                    // Mache den Zug im Game
                    var moveObj = {
                        from: from,
                        to: to,
                        promotion: promotion
                    };

                    var result = game.move(moveObj);

                    if (result) {
                        currentMoveIndex++;

                        // Speichere in History
                        moveHistory.push({
                            move: result,
                            fen: game.fen()
                        });

                        // Update Board
                        renderBoard();
                        $(`[data-square="${from}"]`).addClass('highlight-last-move from');
                        $(`[data-square="${to}"]`).addClass('highlight-last-move to');

                        // Pr√ºfe ob das Puzzle jetzt gel√∂st ist
                        if (currentMoveIndex >= currentSolutionMoves.length) {
                            showSuccessMessage();
                            showCoachMessage('Ausgezeichnet!', 'Du hast das Puzzle erfolgreich gel√∂st!');
                            submitPuzzleResult(true);
                            $('#btnNext').addClass('active'); // Button gr√ºn highlighten
                        } else {
                            // Gib Feedback und fordere n√§chsten Zug an mit taktischer Erkl√§rung
                            var pattern = currentPuzzle.tactical_pattern || 'hangingPiece';
                            var explanation = getPatternExplanation(pattern, currentMoveIndex, false);
                            showCoachMessage('N√§chster Zug', explanation);
                        }
                    } else {
                        console.error('Failed to play opponent move:', opponentMove);
                    }
                }, 800); // 800ms Verz√∂gerung

                return true;
            }
        } else {
            // Falscher Zug - zeige rotes X und gib hilfreiche Erkl√§rung
            showVisualFeedback(to, false); // Rotes X
            var pattern = currentPuzzle.tactical_pattern || 'hangingPiece';
            var explanation = getPatternExplanation(pattern, currentMoveIndex, false);
            showCoachMessage('Noch nicht ganz...', explanation);

            // Zug zur√ºcknehmen
            game.undo();

            // Board neu rendern (reset zum Ausgangszustand)
            renderBoard();

            // Entferne alle Highlights
            removeHighlights();
            selectedSquare = null;

            return false;
        }
    }

    // Sende Puzzle-Ergebnis an Backend
    function submitPuzzleResult(solved) {
        if (!currentPuzzle) return;

        // Berechne L√∂sungszeit
        if (solved && puzzleStartTime && !puzzleSolveTime) {
            puzzleSolveTime = Math.floor((Date.now() - puzzleStartTime) / 1000); // in Sekunden
            console.log('Puzzle gel√∂st in', puzzleSolveTime, 'Sekunden');
        }

        // Extrahiere prim√§res taktisches Pattern
        var primaryPattern = null;
        if (currentPuzzle.themes && currentPuzzle.themes.length > 0) {
            // Nehme das erste Theme als prim√§res Pattern
            primaryPattern = currentPuzzle.themes[0];
        }

        $.ajax({
            url: '/api/submit-puzzle',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                puzzle_id: currentPuzzle.id,
                solved: solved,
                error_type: currentPuzzle.error_type,
                solve_time_seconds: puzzleSolveTime,
                rating: currentPuzzle.rating,
                tactical_pattern: primaryPattern
            }),
            success: function(response) {
                console.log('Puzzle-Ergebnis gespeichert:', response);
            },
            error: function(xhr, status, error) {
                console.error('Fehler beim Speichern:', error);
            }
        });
    }
</script>
{% endblock %}
